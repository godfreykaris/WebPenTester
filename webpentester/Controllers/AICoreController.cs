using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using Microsoft.AspNetCore.Razor.TagHelpers;
using Newtonsoft.Json;

namespace webpentester.AICoreController
{
    /* Signals traveling through the neurons of the network
     * Each neuron's has an output value (Output) of the signal generated from its inputs
     */
    public interface INeuronSignal
    {
        double Output { get; set; } // Signals output value
    }

    /* The INeuronReceptor interface defines the input of a neuron, i.e. the output from many other neurons.
     * 
     * The generic dictionary is used where the key is a signal and the output is a class defining 
     * the "weight" of that signal.
     * 
     */
    public interface INeuronReceptor
    {
        Dictionary<INeuronSignal, NeuralFactor> Input { get; }
    }

    /* The NeuralFactor class stores not only the weight of the signal,
     * but also the amount of adjustment to be applied when updating.
     * 
     * It keeps track of the weight and change of a neuron's input
     */
    public class NeuralFactor
    {
        #region Constructors
        public NeuralFactor(double weight)
        {
            m_weight = weight;
            m_delta = 0;
        }
        #endregion

        #region Member Variables
        public double m_weight;

        /* The delta represents the contribution of the weight to the overall error of the network 
         * and is used to update the weight during the learning process.
         */
        public double m_delta;
        #endregion

        #region Properties
        public double Weight
        {
            get { return m_weight; }
            set { m_weight = value; }
        }

        public double Delta
        {
            get { return m_delta; }
            set { m_delta = value; }
        }
        #endregion

        #region Methods
        public void ApplyDelta()
        {
            m_weight += m_delta;
            m_delta = 0;
        }
        #endregion
    }

    /* This interface defines a Neuron
     * Each neuron is a receptor as well as a signal so we inherit from them 
     */
    public interface INeuron : INeuronSignal, INeuronReceptor
    {
        /* The Pulse method represents the process of activating the neuron in response 
         * to incoming signals from the previous layer in the neural network.
         */
        void Pulse(INeuralLayer layer);

        /* The ApplyLearning method represents the process of applying learning or adjusting 
         * the weights of the neuron based on the error calculated during the learning process.
         */
        void ApplyLearning(INeuralLayer layer);

        /* A Bias is an additional input to the neuron that helps control 
         * the neuron's activation threshold. 
         */
        NeuralFactor Bias { get; set; }
        double BiasWeight { get; set; } // Weight of the Bias input
        double Error { get; set; } //  The error associated with the neuron during the learning process
    }

    /* Defination of a layer of neurons in the neural network 
     */
    public interface INeuralLayer : IList<INeuron>
    {
        /* The Pulse method represents the process of propagating signals through the layer of neurons.
         * It typically involves activating each neuron in the layer by calling their respective Pulse methods.
         */
        void Pulse(INeuralNet net);

        /* The ApplyLearning method represents the process of applying learning or training
         * to the neurons in the layer.
         * It typically involves calling the ApplyLearning method of each neuron in the layer.
         */
        void ApplyLearning(INeuralNet net);
    }

    /* The neural network itself. */
    public interface INeuralNet
    {
        INeuralLayer HiddenLayer { get; set; }
        INeuralLayer OutputLayer { get; set; }
        INeuralLayer InputLayer { get; set; }

        void Pulse(); // Triggers the propagation of signals through the network
        void ApplyLearning(); // Initiates the learning process
    }

    public class Neuron : INeuron
    {
        #region Fields
        NeuralFactor m_bias;
        double m_biasWeight;
        double m_error;
        Dictionary<INeuronSignal, NeuralFactor> m_input;
        double m_output;
        #endregion

        #region Properties
        public NeuralFactor Bias
        {
            get { return m_bias; }
            set { m_bias = value; }
        }

        public double BiasWeight
        {
            get { return m_biasWeight; }
            set { m_biasWeight = value; }
        }

        public double Error
        {
            get { return m_error; }
            set { m_error = value; }
        }

        public Dictionary<INeuronSignal, NeuralFactor> Input
        {
            get { return m_input; }
        }

        public double Output
        {
            get { return m_output; }
            set { m_output = value; }
        }
        #endregion

        #region Methods

        public Neuron()
        {
            m_bias = new NeuralFactor(0.0);
            m_input = new Dictionary<INeuronSignal, NeuralFactor>();
        }

        public void Pulse(INeuralLayer layer)
        {
            lock(this)
            {
                m_output = 0;
                foreach(KeyValuePair<INeuronSignal, NeuralFactor> item in m_input)
                {
                    m_output += item.Key.Output * item.Value.Weight;
                }

                m_output += m_bias.Weight * BiasWeight;
                m_output = Sigmoid(m_output);
            }
        }

        public void ApplyLearning(INeuralLayer layer)
        {

        }

        private static double Sigmoid(double value)
        {
            return 1 / (1 + Math.Exp(-value));
        }

        #endregion
    }

    public class NeuralLayer : List<INeuron>, INeuralLayer
    {
        #region Fields
        private List<INeuron> m_neurons;
        private bool m_isReadOnly;
        #endregion

        #region Properties
        
        public bool IsReadOnly
        {
            get { return m_isReadOnly; }
            set { m_isReadOnly = value; }
        }

        public new INeuron this[int index]
        {
            get { return m_neurons[index]; }
            set
            {
                if (m_isReadOnly)
                {
                    throw new InvalidOperationException("NeuralLayer is read-only.");
                }

                m_neurons[index] = value;
            }
        }

        public new int Count
        {
            get { return m_neurons.Count; }
        }
        #endregion

        #region Methods

        public NeuralLayer()
        {
            m_neurons = new List<INeuron>();
            m_isReadOnly = false;
        }

        public void Pulse(INeuralNet net)
        {
            foreach(INeuron n in m_neurons)
            {
                n.Pulse(this);
            }
        }
        
        public void ApplyLearning(INeuralNet net)
        {
            foreach(INeuron n in m_neurons)
            {
                n.ApplyLearning(this);
            }
        }
        public new void Add(INeuron neuron)
        {
            if (m_isReadOnly)
            {
                throw new InvalidOperationException("NeuralLayer is read-only. Cannot add neurons.");
            }

            m_neurons.Add(neuron);
        }

        
        public new void Insert(int index, INeuron neuron)
        {
            if (m_isReadOnly)
            {
                throw new InvalidOperationException("NeuralLayer is read-only. Cannot insert neurons.");
            }

            m_neurons.Insert(index, neuron);
        }

        public new bool Remove(INeuron neuron)
        {
            if (m_isReadOnly)
            {
                throw new InvalidOperationException("NeuralLayer is read-only. Cannot remove neurons.");
            }

            return m_neurons.Remove(neuron);
        }

        public new void RemoveAt(int index)
        {
            if (m_isReadOnly)
            {
                throw new InvalidOperationException("NeuralLayer is read-only. Cannot remove neurons.");
            }

            m_neurons.RemoveAt(index);
        }

        public new void Clear()
        {
            if (m_isReadOnly)
            {
                throw new InvalidOperationException("NeuralLayer is read-only. Cannot clear neurons.");
            }

            m_neurons.Clear();
        }

        #endregion
    }

    public class NeuralNet : INeuralNet
    {
        #region Fields
        INeuralLayer m_hiddenLayer;
        INeuralLayer m_inputLayer;
        INeuralLayer m_outputLayer;
        double m_learningRate;
        #endregion

        #region Properties
        public INeuralLayer HiddenLayer
        {
            get { return m_hiddenLayer; }
            set { m_hiddenLayer = value; }
        }

        public INeuralLayer InputLayer
        {
            get { return m_inputLayer; }
            set { m_inputLayer = value; }
        }

        public INeuralLayer OutputLayer
        {
            get { return m_outputLayer; }
            set { m_outputLayer = value; }
        }
        #endregion

        #region
        public void Pulse()
        {
            lock(this)
            {
                m_hiddenLayer.Pulse(this);
                m_outputLayer.Pulse(this);
            }
        }

        public void ApplyLearning()
        {
            lock(this)
            {
                m_hiddenLayer.ApplyLearning(this);
                m_outputLayer.ApplyLearning(this);
            }
        }

        public void Initialize(int randomSeed, int inputNeuronCount, int hiddenNeuronCount, int outputNeuronCount)
        {
            int i, j;
            Random rand;

            // Initializations
            rand = new Random(randomSeed);

            m_inputLayer = new NeuralLayer();
            m_hiddenLayer = new NeuralLayer();
            m_outputLayer = new NeuralLayer();

            for (i = 0; i < inputNeuronCount; i++)
            {
                m_inputLayer.Add(new Neuron());
            }

            for (i = 0; i < hiddenNeuronCount; i++)
            {
                m_hiddenLayer.Add(new Neuron());
            }

            for (i = 0; i < outputNeuronCount; i++)
            {
                m_outputLayer.Add(new Neuron());
            }

            // Wire-up the input layer to the hidden layer
            for(i = 0; i < m_hiddenLayer.Count; i++)
            {
                for(j = 0; j < m_inputLayer.Count; j++)
                {
                    m_hiddenLayer[i].Input.Add(m_inputLayer[j], new NeuralFactor(rand.NextDouble()));
                }
            }

            // Wire-up the hidden layer to the output layer
            for (i = 0; i < m_outputLayer.Count; i++)
            {
                for (j = 0; j < m_hiddenLayer.Count; j++)
                {
                    m_outputLayer[i].Input.Add(m_hiddenLayer[j], new NeuralFactor(rand.NextDouble()));
                }
            }
        }

        private void BackPropagation(double[] desiredResults)
        {
            int i, j;
            double temp, error;
            INeuron inputNode, hiddenNode, outputNode, node;

            // Calculate output error values
            for(i = 0; i < m_outputLayer.Count; i++)
            {
                temp = m_outputLayer[i].Output;
                m_outputLayer[i].Error = (desiredResults[i] - temp) * temp * (1.0F - temp);
            }

            // Calculate hidden layer error values
            for(i = 0; i < m_hiddenLayer.Count; i++)
            {
                node = m_hiddenLayer[i];
                error = 0;

                for(j = 0; j < m_outputLayer.Count; j++)
                {
                    outputNode = m_outputLayer[j];
                    error += outputNode.Error * outputNode.Input[node].Weight * node.Output * (1.0F - node.Output);
                }

                node.Error = error;
            }

            // Adjust output layer weight change
            for( i = 0; i < m_hiddenLayer.Count; i++)
            {
                node = m_hiddenLayer[i];

                for(j = 0; j < m_outputLayer.Count; j++)
                {
                    outputNode = m_outputLayer[j];
                    outputNode.Input[node].Weight += m_learningRate * m_outputLayer[j].Error * node.Output;
                    outputNode.Bias.Delta += m_learningRate * m_outputLayer[j].Error * outputNode.Bias.Weight;
                }
            }

            // Adjust hidden layer weight change  
            for (i = 0; i < m_inputLayer.Count; i++)
            {
                inputNode = m_inputLayer[i];
                for (j = 0; j < m_hiddenLayer.Count; j++)
                {
                    hiddenNode = m_hiddenLayer[j];
                    hiddenNode.Input[inputNode].Weight += m_learningRate * hiddenNode.Error * inputNode.Output;
                    hiddenNode.Bias.Delta += m_learningRate * hiddenNode.Error * inputNode.Bias.Weight;
                }
            }
        }

        public void Train(double[] input, double[] desiredResult)
        {
            int i;
            if (input.Length != m_inputLayer.Count)
            {
                throw new ArgumentException(string.Format("Expecting {0} inputs for this network", m_inputLayer.Count));
            }

            // Initialize data
            for( i = 0; i < m_inputLayer.Count; i++)
            {
                Neuron n = m_inputLayer[i] as Neuron;

                if (null != n)
                    n.Output = input[i];
            }

            Pulse();
            BackPropagation(desiredResult);
        }

        public void Train(double[][] inputs, double[][] expected)
        {
            for (int i = 0; i < inputs.Length; i++)
            {
                Train(inputs[i], expected[i]);
            }
        }

        public NeuralNet()
        {
            m_inputLayer = new NeuralLayer();
            m_hiddenLayer = new NeuralLayer();
            m_outputLayer = new NeuralLayer();

            m_learningRate = 0.1;
        }

        #endregion
    }
}
